diff --git a/.flowconfig b/.flowconfig
index fa03d71..de58717 100644
--- a/.flowconfig
+++ b/.flowconfig
@@ -11,6 +11,7 @@
 ./flow-typed/npm
 
 [options]
+suppress_comment= \\(.\\|\n\\)*\\$FlowIgnore
 
 [version]
 0.71.0
diff --git a/packages/jaeger-ui/src/components/TraceDiff/TraceDiffGraph/TraceDiffGraph.js b/packages/jaeger-ui/src/components/TraceDiff/TraceDiffGraph/TraceDiffGraph.js
index 89373e6..9f52443 100644
--- a/packages/jaeger-ui/src/components/TraceDiff/TraceDiffGraph/TraceDiffGraph.js
+++ b/packages/jaeger-ui/src/components/TraceDiff/TraceDiffGraph/TraceDiffGraph.js
@@ -18,22 +18,27 @@ import * as React from 'react';
 import { DirectedGraph, LayoutManager } from '@jaegertracing/plexus';
 import _get from 'lodash/get';
 import _map from 'lodash/map';
+import { connect } from 'react-redux';
 
 import drawNode from './drawNode';
 import ErrorMessage from '../../common/ErrorMessage';
 import LoadingIndicator from '../../common/LoadingIndicator';
-import UiFindInput from '../../common/UiFindInput';
+import UiFindInput, { extractUiFindFromState } from '../../common/UiFindInput';
 import { fetchedState } from '../../../constants';
 import convPlexus from '../../../model/trace-dag/convPlexus';
 import TraceDag from '../../../model/trace-dag/TraceDag';
+import filterSpans from '../../../utils/filter-spans';
 
+import type { PVertex } from '../../../model/trace-dag/types';
 import type { FetchedTrace } from '../../../types';
+import type { Trace } from '../../../types/trace';
 
 import './TraceDiffGraph.css';
 
 type Props = {
   a: ?FetchedTrace,
   b: ?FetchedTrace,
+  uiFind?: string,
 };
 
 const { classNameIsSmall } = DirectedGraph.propsFactories;
@@ -69,10 +74,51 @@ export function setOnNode() {
   };
 }
 
-export default class TraceDiffGraph extends React.PureComponent<Props> {
+let lastUiFind: string;
+let lastVertices: PVertex<Object>[];
+let uiFindVertexKeys: Set<number | string>;
+
+export function getUiFindVertexKeys(uiFind: string, vertices: PVertex<Object>[]) {
+  if (uiFind === lastUiFind && vertices === lastVertices && uiFindVertexKeys) {
+    return uiFindVertexKeys;
+  }
+  const newVertexKeys: Set<number | string> = new Set();
+  vertices.forEach(({ key, data: { members } }) => {
+    if (_get(filterSpans(uiFind, _map(members, 'span')), 'size')) {
+      newVertexKeys.add(key);
+    }
+  });
+  lastUiFind = uiFind;
+  lastVertices = vertices;
+  uiFindVertexKeys = newVertexKeys;
+  return newVertexKeys;
+}
+
+let lastAData: ?Trace;
+let lastBData: ?Trace;
+let edgesAndVertices: ?Object;
+
+function getEdgesAndVertices(aData, bData): Object {
+  if (aData === lastAData && bData === lastBData && edgesAndVertices) {
+    return edgesAndVertices;
+  }
+  lastAData = aData;
+  lastBData = bData;
+  const aTraceDag = TraceDag.newFromTrace(aData);
+  const bTraceDag = TraceDag.newFromTrace(bData);
+  const diffDag = TraceDag.diff(aTraceDag, bTraceDag);
+  edgesAndVertices = convPlexus(diffDag.nodesMap);
+  return edgesAndVertices;
+}
+
+class TraceDiffGraph extends React.PureComponent<Props> {
   props: Props;
   layoutManager: LayoutManager;
 
+  static defaultProps = {
+    uiFind: '',
+  };
+
   constructor(props: Props) {
     super(props);
     this.layoutManager = new LayoutManager({ useDotEdges: true, splines: 'polyline' });
@@ -83,7 +129,12 @@ export default class TraceDiffGraph extends React.PureComponent<Props> {
   }
 
   render() {
-    const { a, b } = this.props;
+    const {
+      a,
+      b,
+      // Flow requires `= ''` because it does not interpret defaultProps
+      uiFind = '',
+    } = this.props;
     if (!a || !b) {
       return <h1 className="u-mt-vast u-tx-muted ub-tx-center">At least two Traces are needed</h1>;
     }
@@ -115,11 +166,8 @@ export default class TraceDiffGraph extends React.PureComponent<Props> {
     if (!aData || !bData) {
       return <div className="TraceDiffGraph--graphWrapper" />;
     }
-    const aTraceDag = TraceDag.newFromTrace(aData);
-    const bTraceDag = TraceDag.newFromTrace(bData);
-    const diffDag = TraceDag.diff(aTraceDag, bTraceDag);
-    const { edges, vertices } = convPlexus(diffDag.nodesMap);
-    const spansArray = _map(_map(vertices, 'data.members'), member => _map(member, 'span'));
+    const { edges, vertices } = getEdgesAndVertices(aData, bData);
+    const keys = getUiFindVertexKeys(uiFind, vertices);
 
     return (
       <div className="TraceDiffGraph--graphWrapper">
@@ -130,7 +178,7 @@ export default class TraceDiffGraph extends React.PureComponent<Props> {
           className="TraceDiffGraph--dag"
           minimapClassName="TraceDiffGraph--miniMap"
           layoutManager={this.layoutManager}
-          getNodeLabel={drawNode}
+          getNodeLabel={drawNode(keys)}
           setOnRoot={classNameIsSmall}
           setOnEdgesContainer={setOnEdgesContainer}
           setOnNodesContainer={setOnNodesContainer}
@@ -138,16 +186,18 @@ export default class TraceDiffGraph extends React.PureComponent<Props> {
           edges={edges}
           vertices={vertices}
         />
-        <div className="TraceDiffGraph--uiFind">
-          <label htmlFor="uiFind--input">
-            <span>Find</span>
-          </label>
+        <label className="TraceDiffGraph--uiFind">
+          <span>Find</span>
           <UiFindInput
-            spansArray={spansArray}
-            inputProps={{ className: 'TraceDiffGraph--uiFind--input', id: 'uiFind--input' }}
+            inputProps={{
+              className: 'TraceDiffGraph--uiFind--input',
+              suffix: uiFind.length && String(keys.size),
+            }}
           />
-        </div>
+        </label>
       </div>
     );
   }
 }
+
+export default connect(extractUiFindFromState)(TraceDiffGraph);
diff --git a/packages/jaeger-ui/src/components/TracePage/TraceGraph/OpNode.js b/packages/jaeger-ui/src/components/TracePage/TraceGraph/OpNode.js
index edb1b63..6f22c73 100644
--- a/packages/jaeger-ui/src/components/TracePage/TraceGraph/OpNode.js
+++ b/packages/jaeger-ui/src/components/TracePage/TraceGraph/OpNode.js
@@ -17,17 +17,11 @@
 import * as React from 'react';
 import { Popover } from 'antd';
 import cx from 'classnames';
-import _get from 'lodash/get';
-import _map from 'lodash/map';
-import _memoize from 'lodash/memoize';
-import { connect } from 'react-redux';
 
 import CopyIcon from '../../common/CopyIcon';
-import { extractUiFindFromState } from '../../common/UiFindInput';
 import colorGenerator from '../../../utils/color-generator';
-import filterSpans from '../../../utils/filter-spans';
 
-import type { PVertex, DenseSpan } from '../../../model/trace-dag/types';
+import type { PVertex } from '../../../model/trace-dag/types';
 
 import './OpNode.css';
 
@@ -41,8 +35,7 @@ type Props = {
   operation: string,
   service: string,
   mode: string,
-  uiFind: string,
-  members: DenseSpan[],
+  isUiFindMatch: boolean,
 };
 
 export const MODE_SERVICE = 'service';
@@ -72,100 +65,93 @@ export function round2(percent: number) {
   return Math.round(percent * 100) / 100;
 }
 
-export default class OpNode extends React.PureComponent<Props> {
-  props: Props;
-  filterSpans: typeof filterSpans;
-  static defaultProps = {
-    uiFind: '',
-  };
-
-  constructor(props: Props) {
-    super(props);
-    this.filterSpans = _memoize(filterSpans);
+export default function OpNode(props: Props) {
+  const {
+    count,
+    errors,
+    time,
+    percent,
+    selfTime,
+    percentSelfTime,
+    operation,
+    service,
+    mode,
+    // uiFind,
+    isUiFindMatch,
+  } = props;
+
+  // Spans over 20 % time are full red - we have probably to reconsider better approach
+  let backgroundColor;
+  if (mode === MODE_TIME) {
+    const percentBoosted = Math.min(percent / 20, 1);
+    backgroundColor = [255, 0, 0, percentBoosted].join();
+  } else if (mode === MODE_SELFTIME) {
+    backgroundColor = [255, 0, 0, percentSelfTime / 100].join();
+  } else {
+    backgroundColor = colorGenerator
+      .getRgbColorByKey(service)
+      .concat(0.8)
+      .join();
   }
 
-  render() {
-    const {
-      count,
-      errors,
-      time,
-      percent,
-      selfTime,
-      percentSelfTime,
-      operation,
-      service,
-      mode,
-      uiFind,
-    } = this.props;
-
-    // Spans over 20 % time are full red - we have probably to reconsider better approach
-    let backgroundColor;
-    if (mode === MODE_TIME) {
-      const percentBoosted = Math.min(percent / 20, 1);
-      backgroundColor = [255, 0, 0, percentBoosted].join();
-    } else if (mode === MODE_SELFTIME) {
-      backgroundColor = [255, 0, 0, percentSelfTime / 100].join();
-    } else {
-      backgroundColor = colorGenerator
-        .getRgbColorByKey(service)
-        .concat(0.8)
-        .join();
-    }
-
-    const className = cx('OpNode', `OpNode--mode-${mode}`, {
-      'is-ui-find-match': _get(this.filterSpans(uiFind, _map(this.props.members, 'span')), 'size'),
-    });
-
-    const table = (
-      <table className={className} cellSpacing="0">
-        <tbody
-          className="OpNode--body"
-          style={{
-            background: `rgba(${backgroundColor})`,
-          }}
-        >
-          <tr>
-            <td className="OpNode--metricCell OpNode--count">
-              {count} / {errors}
-            </td>
-            <td className="OpNode--labelCell OpNode--service">
-              <strong>{service}</strong>
-              <CopyIcon
-                className="OpNode--copyIcon"
-                copyText={`${service} ${operation}`}
-                tooltipTitle="Copy label"
-              />
-            </td>
-            <td className="OpNode--metricCell OpNode--avg">{round2(time / 1000 / count)} ms</td>
-          </tr>
-          <tr>
-            <td className="OpNode--metricCell OpNode--time">
-              {time / 1000} ms ({round2(percent)} %)
-            </td>
-            <td className="OpNode--labelCell OpNode--op">{operation}</td>
-            <td className="OpNode--metricCell OpNode--selfTime">
-              {selfTime / 1000} ms ({round2(percentSelfTime)} %)
-            </td>
-          </tr>
-        </tbody>
-      </table>
-    );
-
-    return (
-      <Popover overlayClassName="OpNode--popover" mouseEnterDelay={0.25} content={table}>
-        {table}
-      </Popover>
-    );
-  }
+  const className = cx('OpNode', `OpNode--mode-${mode}`, {
+    'is-ui-find-match': isUiFindMatch,
+  });
+
+  const table = (
+    <table className={className} cellSpacing="0">
+      <tbody
+        className="OpNode--body"
+        style={{
+          background: `rgba(${backgroundColor})`,
+        }}
+      >
+        <tr>
+          <td className="OpNode--metricCell OpNode--count">
+            {count} / {errors}
+          </td>
+          <td className="OpNode--labelCell OpNode--service">
+            <strong>{service}</strong>
+            <CopyIcon
+              className="OpNode--copyIcon"
+              copyText={`${service} ${operation}`}
+              tooltipTitle="Copy label"
+            />
+          </td>
+          <td className="OpNode--metricCell OpNode--avg">{round2(time / 1000 / count)} ms</td>
+        </tr>
+        <tr>
+          <td className="OpNode--metricCell OpNode--time">
+            {time / 1000} ms ({round2(percent)} %)
+          </td>
+          <td className="OpNode--labelCell OpNode--op">{operation}</td>
+          <td className="OpNode--metricCell OpNode--selfTime">
+            {selfTime / 1000} ms ({round2(percentSelfTime)} %)
+          </td>
+        </tr>
+      </tbody>
+    </table>
+  );
+
+  return (
+    <Popover overlayClassName="OpNode--popover" mouseEnterDelay={0.25} content={table}>
+      {table}
+    </Popover>
+  );
 }
 
-const ConnectedOpNode = connect(extractUiFindFromState)(OpNode);
-
-export function getNodeDrawer(mode: string) {
+export function getNodeDrawer(mode: string, uiFindVertexKeys: Set<number | string>) {
   return function drawNode<T>(vertex: PVertex<T>) {
     const { data, members, operation, service } = vertex.data;
     return (
-      <ConnectedOpNode {...data} members={members} mode={mode} operation={operation} service={service} />
+      <OpNode
+        {...data}
+        isUiFindMatch={uiFindVertexKeys.has(vertex.key)}
+        smembers={members}
+        mode={mode}
+        operation={operation}
+        service={service}
+      />
     );
   };
 }
diff --git a/packages/jaeger-ui/src/components/TracePage/TraceGraph/TraceGraph.js b/packages/jaeger-ui/src/components/TracePage/TraceGraph/TraceGraph.js
index dc7f234..ba9fac4 100644
--- a/packages/jaeger-ui/src/components/TracePage/TraceGraph/TraceGraph.js
+++ b/packages/jaeger-ui/src/components/TracePage/TraceGraph/TraceGraph.js
@@ -17,33 +17,20 @@
 import * as React from 'react';
 import { Card, Icon, Button, Tooltip } from 'antd';
 import { DirectedGraph, LayoutManager } from '@jaegertracing/plexus';
-import DRange from 'drange';
 
 import { getNodeDrawer, MODE_SERVICE, MODE_TIME, MODE_SELFTIME, HELP_TABLE } from './OpNode';
-import convPlexus from '../../../model/trace-dag/convPlexus';
-import TraceDag from '../../../model/trace-dag/TraceDag';
 import {
   setOnEdgesContainer,
   setOnNodesContainer,
   setOnNode,
 } from '../../TraceDiff/TraceDiffGraph/TraceDiffGraph';
 
-import type { Trace, Span, KeyValuePair } from '../../../types/trace';
-
 import './TraceGraph.css';
 
-type SumSpan = {
-  count: number,
-  errors: number,
-  time: number,
-  percent: number,
-  selfTime: number,
-  percentSelfTime: number,
-};
-
 type Props = {
   headerHeight: number,
-  trace: Trace,
+  ev: Object,
+  uiFindVertexKeys: Set<number | string>,
 };
 type State = {
   showHelp: boolean,
@@ -56,29 +43,6 @@ export function setOnEdgePath(e: any) {
   return e.followsFrom ? { strokeDasharray: 4 } : {};
 }
 
-function extendFollowsFrom(edges: any, nodes: any) {
-  return edges.map(e => {
-    let hasChildOf = true;
-    if (typeof e.to === 'number') {
-      const n = nodes[e.to];
-      hasChildOf = n.members.some(
-        m => m.span.references && m.span.references.some(r => r.refType === 'CHILD_OF')
-      );
-    }
-    return { ...e, followsFrom: !hasChildOf };
-  });
-}
-
-export function isError(tags: Array<KeyValuePair>) {
-  if (tags) {
-    const errorTag = tags.find(t => t.key === 'error');
-    if (errorTag) {
-      return errorTag.value;
-    }
-  }
-  return false;
-}
-
 const HELP_CONTENT = (
   <div className="TraceGraph--help-content">
     {HELP_TABLE}
@@ -140,7 +104,6 @@ export default class TraceGraph extends React.PureComponent<Props, State> {
   props: Props;
   state: State;
 
-  parentChildOfMap: { [string]: Span[] };
   cache: any;
 
   layoutManager: LayoutManager;
@@ -158,68 +121,6 @@ export default class TraceGraph extends React.PureComponent<Props, State> {
     this.layoutManager.stopAndRelease();
   }
 
-  calculateTraceDag(): TraceDag<SumSpan> {
-    const traceDag: TraceDag<SumSpan> = new TraceDag();
-    traceDag._initFromTrace(this.props.trace, {
-      count: 0,
-      errors: 0,
-      time: 0,
-      percent: 0,
-      selfTime: 0,
-      percentSelfTime: 0,
-    });
-
-    traceDag.nodesMap.forEach(n => {
-      const ntime = n.members.reduce((p, m) => p + m.span.duration, 0);
-      const numErrors = n.members.reduce((p, m) => (p + isError(m.span.tags) ? 1 : 0), 0);
-      const childDurationsDRange = n.members.reduce((p, m) => {
-        // Using DRange to handle overlapping spans (fork-join)
-        const cdr = new DRange(m.span.startTime, m.span.startTime + m.span.duration).intersect(
-          this.getChildOfDrange(m.span.spanID)
-        );
-        return p + cdr.length;
-      }, 0);
-      const stime = ntime - childDurationsDRange;
-      const nd = {
-        count: n.members.length,
-        errors: numErrors,
-        time: ntime,
-        percent: 100 / this.props.trace.duration * ntime,
-        selfTime: stime,
-        percentSelfTime: 100 / ntime * stime,
-      };
-      // eslint-disable-next-line no-param-reassign
-      n.data = nd;
-    });
-    return traceDag;
-  }
-
-  getChildOfDrange(parentID: string): number {
-    const childrenDrange = new DRange();
-    this.getChildOfSpans(parentID).forEach(s => {
-      // -1 otherwise it will take for each child a micro (incluse,exclusive)
-      childrenDrange.add(s.startTime, s.startTime + (s.duration <= 0 ? 0 : s.duration - 1));
-    });
-    return childrenDrange;
-  }
-
-  getChildOfSpans(parentID: string): Span[] {
-    if (!this.parentChildOfMap) {
-      this.parentChildOfMap = {};
-      this.props.trace.spans.forEach(s => {
-        if (s.references) {
-          // Filter for CHILD_OF we don't want to calculate FOLLOWS_FROM (prod-cons)
-          const parentIDs = s.references.filter(r => r.refType === 'CHILD_OF').map(r => r.spanID);
-          parentIDs.forEach((pID: string) => {
-            this.parentChildOfMap[pID] = this.parentChildOfMap[pID] || [];
-            this.parentChildOfMap[pID].push(s);
-          });
-        }
-      });
-    }
-    return this.parentChildOfMap[parentID] || [];
-  }
-
   toggleNodeMode(newMode: string) {
     this.setState({ mode: newMode });
   }
@@ -233,21 +134,19 @@ export default class TraceGraph extends React.PureComponent<Props, State> {
   };
 
   render() {
-    const { headerHeight, trace } = this.props;
+    const { ev, headerHeight, uiFindVertexKeys } = this.props;
     const { showHelp, mode } = this.state;
-    if (!trace) {
+    if (!ev) {
       return <h1 className="u-mt-vast u-tx-muted ub-tx-center">No trace found</h1>;
     }
 
     // Caching edges/vertices so that DirectedGraph is not redrawn
+    /*
     let ev = this.cache;
     if (!ev) {
-      const traceDag = this.calculateTraceDag();
-      const nodes = [...traceDag.nodesMap.values()];
-      ev = convPlexus(traceDag.nodesMap);
-      ev.edges = extendFollowsFrom(ev.edges, nodes);
       this.cache = ev;
     }
+    */
 
     return (
       <div className="TraceGraph--graphWrapper" style={{ paddingTop: headerHeight + 49 }}>
@@ -258,7 +157,7 @@ export default class TraceGraph extends React.PureComponent<Props, State> {
           className="TraceGraph--dag"
           minimapClassName="TraceGraph--miniMap"
           layoutManager={this.layoutManager}
-          getNodeLabel={getNodeDrawer(mode)}
+          getNodeLabel={getNodeDrawer(mode, uiFindVertexKeys)}
           setOnRoot={classNameIsSmall}
           setOnEdgePath={setOnEdgePath}
           setOnEdgesContainer={setOnEdgesContainer}
diff --git a/packages/jaeger-ui/src/components/TracePage/TraceGraph/calculateTraceDagEV.js b/packages/jaeger-ui/src/components/TracePage/TraceGraph/calculateTraceDagEV.js
new file mode 100644
index 0000000..6b35ad1
--- /dev/null
+++ b/packages/jaeger-ui/src/components/TracePage/TraceGraph/calculateTraceDagEV.js
@@ -0,0 +1,125 @@
+// @flow
+
+// Copyright (c) 2019 The Jaeger Authors.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+import DRange from 'drange';
+
+import convPlexus from '../../../model/trace-dag/convPlexus';
+import TraceDag from '../../../model/trace-dag/TraceDag';
+import type { Trace, Span, KeyValuePair } from '../../../types/trace';
+
+type SumSpan = {
+  count: number,
+  errors: number,
+  time: number,
+  percent: number,
+  selfTime: number,
+  percentSelfTime: number,
+};
+
+let parentChildOfMap: { [string]: Span[] };
+
+export function isError(tags: Array<KeyValuePair>) {
+  if (tags) {
+    const errorTag = tags.find(t => t.key === 'error');
+    if (errorTag) {
+      return errorTag.value;
+    }
+  }
+  return false;
+}
+
+function extendFollowsFrom(edges: any, nodes: any) {
+  return edges.map(e => {
+    let hasChildOf = true;
+    if (typeof e.to === 'number') {
+      const n = nodes[e.to];
+      hasChildOf = n.members.some(
+        m => m.span.references && m.span.references.some(r => r.refType === 'CHILD_OF')
+      );
+    }
+    return { ...e, followsFrom: !hasChildOf };
+  });
+}
+
+function getChildOfSpans(parentID: string, trace: Trace): Span[] {
+  if (!parentChildOfMap) {
+    parentChildOfMap = {};
+    trace.spans.forEach(s => {
+      if (s.references) {
+        // Filter for CHILD_OF we don't want to calculate FOLLOWS_FROM (prod-cons)
+        const parentIDs = s.references.filter(r => r.refType === 'CHILD_OF').map(r => r.spanID);
+        parentIDs.forEach((pID: string) => {
+          parentChildOfMap[pID] = parentChildOfMap[pID] || [];
+          parentChildOfMap[pID].push(s);
+        });
+      }
+    });
+  }
+  return parentChildOfMap[parentID] || [];
+}
+
+function getChildOfDrange(parentID: string, trace: Trace): number {
+  const childrenDrange = new DRange();
+  getChildOfSpans(parentID, trace).forEach(s => {
+    // -1 otherwise it will take for each child a micro (incluse,exclusive)
+    childrenDrange.add(s.startTime, s.startTime + (s.duration <= 0 ? 0 : s.duration - 1));
+  });
+  return childrenDrange;
+}
+
+export function calculateTraceDag(trace: Trace): TraceDag<SumSpan> {
+  const traceDag: TraceDag<SumSpan> = new TraceDag();
+  traceDag._initFromTrace(trace, {
+    count: 0,
+    errors: 0,
+    time: 0,
+    percent: 0,
+    selfTime: 0,
+    percentSelfTime: 0,
+  });
+
+  traceDag.nodesMap.forEach(n => {
+    const ntime = n.members.reduce((p, m) => p + m.span.duration, 0);
+    const numErrors = n.members.reduce((p, m) => (p + isError(m.span.tags) ? 1 : 0), 0);
+    const childDurationsDRange = n.members.reduce((p, m) => {
+      // Using DRange to handle overlapping spans (fork-join)
+      const cdr = new DRange(m.span.startTime, m.span.startTime + m.span.duration).intersect(
+        getChildOfDrange(m.span.spanID, trace)
+      );
+      return p + cdr.length;
+    }, 0);
+    const stime = ntime - childDurationsDRange;
+    const nd = {
+      count: n.members.length,
+      errors: numErrors,
+      time: ntime,
+      percent: 100 / trace.duration * ntime,
+      selfTime: stime,
+      percentSelfTime: 100 / ntime * stime,
+    };
+    // eslint-disable-next-line no-param-reassign
+    n.data = nd;
+  });
+  return traceDag;
+}
+
+export default function calculateTraceDagEV(trace: Trace) {
+  const traceDag = calculateTraceDag(trace);
+  const nodes = [...traceDag.nodesMap.values()];
+  const ev = convPlexus(traceDag.nodesMap);
+  ev.edges = extendFollowsFrom(ev.edges, nodes);
+  return ev;
+}
diff --git a/packages/jaeger-ui/src/components/TracePage/index.js b/packages/jaeger-ui/src/components/TracePage/index.js
index 1a8720b..ce4f142 100644
--- a/packages/jaeger-ui/src/components/TracePage/index.js
+++ b/packages/jaeger-ui/src/components/TracePage/index.js
@@ -31,6 +31,7 @@ import { trackRange } from './index.track';
 import { merge as mergeShortcuts, reset as resetShortcuts } from './keyboard-shortcuts';
 import { cancel as cancelScroll, scrollBy, scrollTo } from './scroll-page';
 import ScrollManager from './ScrollManager';
+import calculateTraceDagEV from './TraceGraph/calculateTraceDagEV';
 import TraceGraph from './TraceGraph/TraceGraph';
 import { trackSlimHeaderToggle } from './TracePageHeader/TracePageHeader.track';
 import TracePageHeader from './TracePageHeader';
@@ -40,6 +41,7 @@ import ErrorMessage from '../common/ErrorMessage';
 import LoadingIndicator from '../common/LoadingIndicator';
 import { extractUiFindFromState } from '../common/UiFindInput';
 import * as jaegerApiActions from '../../actions/jaeger-api';
+import { getUiFindVertexKeys } from '../TraceDiff/TraceDiffGraph/TraceDiffGraph';
 import { fetchedState } from '../../constants';
 import filterSpans from '../../utils/filter-spans';
 import updateUiFind from '../../utils/update-ui-find';
@@ -111,6 +113,7 @@ export class TracePageImpl extends React.PureComponent<TracePageProps, TracePage
   _filterSpans: typeof filterSpans;
   _searchBar: { current: Input | null };
   _scrollManager: ScrollManager;
+  traceDagEV: Object;
 
   constructor(props: TracePageProps) {
     super(props);
@@ -264,6 +267,9 @@ export class TracePageImpl extends React.PureComponent<TracePageProps, TracePage
 
   toggleTraceGraphView = () => {
     const { traceGraphView } = this.state;
+    if (this.props.trace && this.props.trace.data) {
+      this.traceDagEV = calculateTraceDagEV(this.props.trace.data);
+    }
     this.setState({ traceGraphView: !traceGraphView });
   };
 
@@ -308,7 +314,10 @@ export class TracePageImpl extends React.PureComponent<TracePageProps, TracePage
       return <ErrorMessage className="ub-m3" error={trace.error || 'Unknown error'} />;
     }
 
-    const findMatchesIDs = this._filterSpans(textFilter || '', _get(trace, 'data.spans'));
+    // $FlowIgnore because flow believes Set<string> cannot be assigned to Set<string | number>
+    const findMatches: Set<string | number> = traceGraphView
+      ? getUiFindVertexKeys(textFilter || '', this.traceDagEV.vertices)
+      : this._filterSpans(textFilter || '', _get(trace, 'data.spans'));
     const isEmbedded = Boolean(embedded);
     const headerProps = {
       slimView,
@@ -326,7 +335,7 @@ export class TracePageImpl extends React.PureComponent<TracePageProps, TracePage
       onTraceGraphViewClicked: this.toggleTraceGraphView,
       prevResult: this._scrollManager.scrollToPrevVisibleSpan,
       ref: this._searchBar,
-      resultCount: findMatchesIDs ? findMatchesIDs.size : 0,
+      resultCount: findMatches ? findMatches.size : 0,
       showArchiveButton: !isEmbedded && archiveEnabled,
       showShortcutsHelp: !isEmbedded,
       showStandaloneLink: isEmbedded,
@@ -348,13 +357,13 @@ export class TracePageImpl extends React.PureComponent<TracePageProps, TracePage
         {headerHeight &&
           (traceGraphView ? (
             <section style={{ paddingTop: headerHeight }}>
-              <TraceGraph headerHeight={headerHeight} trace={data} />
+              <TraceGraph headerHeight={headerHeight} ev={this.traceDagEV} uiFindVertexKeys={findMatches} />
             </section>
           ) : (
             <section style={{ paddingTop: headerHeight }}>
               <TraceTimelineViewer
                 registerAccessors={this._scrollManager.setAccessors}
-                findMatchesIDs={findMatchesIDs}
+                findMatchesIDs={findMatches}
                 trace={data}
                 updateNextViewRangeTime={this.updateNextViewRangeTime}
                 updateViewRangeTime={this.updateViewRangeTime}
diff --git a/packages/jaeger-ui/src/components/common/UiFindInput.js b/packages/jaeger-ui/src/components/common/UiFindInput.js
index c044b36..bcceb95 100644
--- a/packages/jaeger-ui/src/components/common/UiFindInput.js
+++ b/packages/jaeger-ui/src/components/common/UiFindInput.js
@@ -17,15 +17,12 @@
 import * as React from 'react';
 import { Input } from 'antd';
 import _debounce from 'lodash/debounce';
-import _filter from 'lodash/filter';
-import _get from 'lodash/get';
 import { connect } from 'react-redux';
 import { withRouter } from 'react-router-dom';
 import queryString from 'query-string';
 
 import type { Location, RouterHistory } from 'react-router-dom';
 
-import filterSpans from '../../utils/filter-spans';
 import updateUiFind from '../../utils/update-ui-find';
 
 import type { ReduxState } from '../../types/index';
@@ -79,18 +76,9 @@ export class UnconnectedUiFindInput extends React.PureComponent<PropsType, State
   render() {
     const inputValue =
       typeof this.state.ownInputValue === 'string' ? this.state.ownInputValue : this.props.uiFind;
-    const suffix: string | null =
-      this.props.uiFind && this.props.spansArray
-        ? String(
-            _filter(this.props.spansArray, spans =>
-              _get(filterSpans(this.props.uiFind /* inputValue */ || '', spans), 'size', 0)
-            ).length
-          )
-        : null;
 
     return (
       <Input
-        suffix={suffix}
         {...this.props.inputProps}
         onBlur={this.handleInputBlur}
         onChange={this.handleInputChange}
diff --git a/packages/plexus/src/LayoutManager/Coordinator.js b/packages/plexus/src/LayoutManager/Coordinator.js
index 683e8fd..cc553cd 100644
--- a/packages/plexus/src/LayoutManager/Coordinator.js
+++ b/packages/plexus/src/LayoutManager/Coordinator.js
@@ -54,7 +54,7 @@ function killWorker(worker: LayoutWorker) {
   // to make flow happy
   const noop = () => {};
   w.onmessage = noop;
-  // $FlowFixMe - https://github.com/facebook/flow/issues/6191
+  // $FlowIgnore - https://github.com/facebook/flow/issues/6191
   w.onmessageerror = noop;
   w.onerror = noop;
   w.terminate();
